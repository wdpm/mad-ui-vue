<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>firework 2</title>
    <style>
        body {
            background-color: #000000;
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<!--<script src="//code.jquery.com/jquery-3.1.1.min.js"></script>-->

<script>
    // canvas
    let canvas = document.querySelector('#canvas');
    let ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let particles = [];
    let rockets = [];
    let maxParticles = 400;
    let mouse = {
        x: 400,
        y: 300
    };

    // init
    setInterval(init, 800);

    // animate
    setInterval(loop, 1000 / 50);

    // Event Listeners
    addEventListener('mousemove', event => {
        mouse.x = event.clientX
        mouse.y = event.clientY
    })

    addEventListener('mousedown', event => {
        console.log("mousedown")
        for (let i = 0; i < 5; i++) {
            // think N as canvas.width
            // [0,2N/3) + N/6 => [N/6,5N/6)
            let x = Math.random() * canvas.width * 2 / 3 + canvas.width / 6;
            launchFrom(x);
        }
    })
    addEventListener('resize', () => {
        canvas.width = innerWidth
        canvas.height = innerHeight
    })

    function init() {
        launchFrom(mouse.x);
    }

    function launchFrom(x) {
        if (rockets.length < 10) {
            let rocket = new Rocket(x);
            rocket.explosionColor = Math.floor(Math.random() * 360 / 10) * 10;
            rocket.vel.y = Math.random() * -3 - 4;//[0,1) * (-3) - 4 => (-3,0] - 4 => (-7,-4]
            rocket.vel.x = Math.random() * 6 - 3;// [0,6) -3 => [-3,3)
            rocket.size = 8;
            rocket.shrink = 0.999;
            rocket.gravity = 0.01;
            rockets.push(rocket);
        }
    }

    function loop() {
        // clear canvas
        ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        let existingRockets = [];

        for (let i = 0; i < rockets.length; i++) {
            // update and draw
            rockets[i].update();
            rockets[i].draw(ctx);

            // calculate distance with Pythagoras
            let distance = Math.sqrt(Math.pow(mouse.x - rockets[i].pos.x, 2) + Math.pow(mouse.y - rockets[i].pos.y, 2));

            // random chance of 1% if rockets is above the middle
            let randomChance = rockets[i].pos.y < (canvas.height * 2 / 3) ? (Math.random() * 100 <= 1) : false;

            /* Explosion rules
                         - 80% of screen
                        - going down
                        - close to the mouse
                        - 1% chance of random explosion
                    */
            if (rockets[i].pos.y < canvas.height / 5 || rockets[i].vel.y >= 0 || distance < 50 || randomChance) {
                rockets[i].explode();
            } else {
                existingRockets.push(rockets[i]);
            }
        }

        rockets = existingRockets;

        let existingParticles = [];
        for (let i = 0; i < particles.length; i++) {
            particles[i].update();

            // draw and save particles that can be rendered
            if (particles[i].exists()) {
                particles[i].draw(ctx);
                existingParticles.push(particles[i]);
            }
        }

        // update array with existing particles - old particles should be garbage collected
        particles = existingParticles;
        while (particles.length > maxParticles) {
            particles.shift();
        }
    }

    class Particle {
        constructor(pos) {
            this.pos = {
                x: pos ? pos.x : 0,
                y: pos ? pos.y : 0
            };

            this.vel = {
                x: 0,
                y: 0
            };

            this.shrink = .97;
            this.size = 2;
            this.resistance = 1;
            this.gravity = 0;
            this.flick = false;
            this.alpha = 1;
            this.fade = 0;
            this.color = 0;
        }

        update() {
            // apply resistance
            this.vel.x *= this.resistance;
            this.vel.y *= this.resistance;

            // gravity down
            this.vel.y += this.gravity;

            // update position based on speed
            this.pos.x += this.vel.x;
            this.pos.y += this.vel.y;

            // shrink
            this.size *= this.shrink;

            // fade out
            this.alpha -= this.fade;
        }

        draw(c) {
            if (!this.exists()) {
                return;
            }

            c.save();
            c.globalCompositeOperation = 'lighter';
            let x = this.pos.x,
                y = this.pos.y,
                r = this.size / 2;
            let gradient = c.createRadialGradient(x, y, 0.1, x, y, r);
            gradient.addColorStop(0.1, "rgba(255,255,255," + this.alpha + ")");
            gradient.addColorStop(0.8, "hsla(" + this.color + ", 100%, 50%, " + this.alpha + ")");
            gradient.addColorStop(1, "hsla(" + this.color + ", 100%, 50%, 0.1)");
            c.fillStyle = gradient;

            c.beginPath();
            c.arc(this.pos.x, this.pos.y, this.flick ? Math.random() * this.size : this.size, 0, Math.PI * 2, true);
            c.closePath();
            c.fill();
            c.restore();
        }

        exists() {
            return this.alpha >= 0.1 && this.size >= 1;
        }
    }

    // Rocket extends Particle but has explosion behavior
    class Rocket extends Particle {
        constructor(x) {
            super({
                x: x,
                y: canvas.height
            });
            this.explosionColor = 0;
        }

        explode() {
            let count = Math.random() * 10 + 80;

            for (let i = 0; i < count; i++) {
                let particle = new Particle(this.pos);
                let angle = Math.random() * Math.PI * 2;

                // emulate 3D effect by using cosine and put more particles in the middle
                let speed = Math.cos(Math.random() * Math.PI / 2) * 15;

                particle.vel.x = Math.cos(angle) * speed;
                particle.vel.y = Math.sin(angle) * speed;

                particle.size = 10;

                particle.gravity = 0.2;
                particle.resistance = 0.92;
                particle.shrink = Math.random() * 0.05 + 0.93;

                particle.flick = true;
                particle.color = this.explosionColor;

                particles.push(particle);
            }
        }

        draw(c) {
            if (!this.exists()) {
                return;
            }

            c.save();
            c.globalCompositeOperation = 'lighter';
            let x = this.pos.x,
                y = this.pos.y,
                r = this.size / 2;
            let gradient = c.createRadialGradient(x, y, 0.1, x, y, r);
            gradient.addColorStop(0.1, "rgba(255, 255, 255 ," + this.alpha + ")");
            gradient.addColorStop(1, "rgba(0, 0, 0, " + this.alpha + ")");

            c.fillStyle = gradient;
            c.beginPath();
            c.arc(this.pos.x, this.pos.y, this.flick ? Math.random() * this.size / 2 + this.size / 2 : this.size, 0, Math.PI * 2, true);
            c.closePath();
            c.fill();
            c.restore();
        }
    }
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: pink;
        }
    </style>
</head>
<body>
<canvas id="canvas">

</canvas>
<!--Particles JS Effect with Pure Vanilla JavaScript | Animated Background Tutorial with Examples-->
<!--https://www.youtube.com/watch?v=d620nV6bp0A&list=WL&index=25-->

<script>
    const canvas = document.querySelector('#canvas')
    const ctx = canvas.getContext('2d')
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight

    let particleArray;

    let mouse = {
        x: undefined,
        y: undefined,
        radius: (canvas.height / 80) * (canvas.height / 80)
    }

    // Event Listeners
    addEventListener('mousemove', event => {
        mouse.x = event.clientX
        mouse.y = event.clientY
    })

    addEventListener('resize', () => {
        canvas.width = innerWidth
        canvas.height = innerHeight
        mouse.radius = (canvas.height / 80) * (canvas.height / 80)
        init()
    })

    class Particle {
        constructor(x, y, directionX, directionY, size, color) {
            this.x = x;
            this.y = y;
            this.directionX = directionX;
            this.directionY = directionY;
            this.size = size;
            this.color = color;
        }

        // method to draw individual particle
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI, false);
            ctx.fillStyle = this.color;
            ctx.fill();
        }

        // check particle position and mouse position relation
        // move particle and redraw the particle
        update() {
            // check if particle is still within canvas
            // if not, adjust to opposite direction
            if (this.x > canvas.width || this.x < 0) {
                this.directionX = -this.directionX;
            }
            if (this.y > canvas.height || this.y < 0) {
                this.directionY = -this.directionY;
            }

            // collision detection
            // distance (mouse center to particle center) < their radius sum
            let dx = mouse.x - this.x;
            let dy = mouse.y - this.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < mouse.radius + this.size) {
                // collision happen

                // this.size * 10, 10 is one int factor reserved for rest space
                const restSpaceFactor = 10;

                // mouse < this and the right of this has space to move
                // then move this a little right
                if (mouse.x < this.x && this.x < canvas.width - this.size * restSpaceFactor) {
                    this.x += 10;
                }

                // mouse > this and the left of this has space to move
                // then move this a little left
                if (mouse.x > this.x && this.x > this.size * restSpaceFactor) {
                    this.x -= 10;
                }

                // y axis same as x axis above
                if (mouse.y < this.y && this.y < canvas.height - this.size * restSpaceFactor) {
                    this.x += 10;
                }

                if (mouse.y > this.y && this.y > this.size * restSpaceFactor) {
                    this.x -= 10;
                }
            }

            // now move particle by directionX/Y
            this.x += this.directionX;
            this.y += this.directionY;

            // draw
            this.draw();
        }

    }

    function init() {
        particleArray = [];
        let numberOfParticles = (canvas.height * canvas.width) / 9000;
        for (let i = 0; i < numberOfParticles; i++) {
            let size = (Math.random() * 5) + 1;
            // x belong to [2* size, innerWidth - 2*size)
            let x = Math.random() * (innerWidth - 2 * size - 2 * size) + 2 * size;
            // y belong to [2* size, innerHeight - 2*size)
            let y = Math.random() * (innerHeight - 2 * size - 2 * size) + 2 * size;

            let directionX = (Math.random() * 5) - 2.5;// [-2.5,2.5)
            let directionY = (Math.random() * 5) - 2.5;// [-2.5,2.5)

            let color = "red";

            particleArray.push(new Particle(x, y, directionX, directionY, size, color))
        }

    }

    function animate() {
        requestAnimationFrame(animate)

        ctx.clearRect(0, 0, canvas.width, canvas.height)

        for (let i = 0; i < particleArray.length; i++) {
            particleArray[i].update();
        }

        connect()
    }

    // connect two particle if their distance is less than one value
    function connect() {
        let opacity = 1;
        for (let i = 0; i < particleArray.length; i++) {
            for (let j = i + 1; j < particleArray.length; j++) {
                // calc distance
                let deltaX = particleArray[i].x - particleArray[j].x;
                let deltaY = particleArray[i].y - particleArray[j].y;
                let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // compare to distance Threshold
                const threshold = Math.sqrt(canvas.width * canvas.height) / 7;
                if (distance < threshold) {
                    // distance sample [20,80]
                    opacity = 1 - (distance / 100);
                    // connect them
                    ctx.strokeStyle = `rgba(0,0,0,${opacity})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath()
                    ctx.moveTo(particleArray[i].x, particleArray[i].y);
                    ctx.lineTo(particleArray[j].x, particleArray[j].y);
                    ctx.stroke();
                }
            }

        }
    }

    init()

    animate()

</script>
</body>
</html>